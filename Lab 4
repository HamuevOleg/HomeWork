#include <cassert>
#include <iostream>
#include <algorithm>
#include <list>
#include <iterator>

//doubleLinkedList :O

class List
{
public:
    class Iterator;
    using ReverseIterator = std::reverse_iterator<Iterator>;

    //Methods
    ~List(); // Just clear but destructor :)
    List();  // Create a list with nothing but constructor :|
    List(const List& copyList); // Something like make copy but constructor :(
    List(List&&) noexcept;
    List(unsigned int n); // Just create a clear value list with some size but constructor :|
    List(const int a[], size_t n); //Something like Make From array but constructor :|
    List(Iterator begin, Iterator end);

    List(std::reverse_iterator<Iterator> rbegin, std::reverse_iterator<Iterator> rend) {
        head = nullptr;
        tail = nullptr;
        size = 0;
        for (auto it = rbegin; it != rend; ++it) {
            pushBack(*it);
        }
    }

    void pushFront(int data);
    void pushBack(int data);
    void popFront();
    void popBack();

    int at(int index);
    bool isEqual(const List *compareWithList) const;
    unsigned int length() const;
    bool empty() const;

    void resize(unsigned int n);
    void assign(unsigned int i, int v)
    {
        clear();
        for (unsigned int j = 0; j < i; ++j) {
            pushBack(v);
        }
    }

    void swap(List& a);
    void print();
    void clear();
    //newMethodLAB4
    static bool is_equal(const List &FirstList, const List &SecondList);
    void newAssign(const Iterator& begin , const Iterator& end)
    {
        clear();

        for (Iterator it = begin; it != end; ++it) {
            pushBack(*it);
        }
    }

    //new methods&operators:
    List &operator=(const List &copyList);
    List &operator=(List &&moveList) noexcept;

    friend bool operator==(const List &leftSideOfEqual, const List &rightSideOfEqual);
    friend bool operator!=(const List &leftSideOfEqual, const List &rightSideOfEqual);

    friend bool operator<(const List &leftSideOfEqual, const List &rightSideOfEqual);

    friend bool operator>(const List &leftSideOfEqual, const List &rightSideOfEqual)
    {
        return rightSideOfEqual < leftSideOfEqual;
    }

    friend bool operator<=(const List&leftSideOfEqual, const List&rightSideOfEqual)
    {
        return !(leftSideOfEqual > rightSideOfEqual);
    }

    friend bool operator>=(const List &leftSideOfEqual, const List &rightSideOfEqual)
    {
        return !(leftSideOfEqual < rightSideOfEqual);
    }

    int operator[](size_t index) const
    {
        Node *currentNode = this->head;
        {
            for (unsigned int i = 0; i < index; ++i) {
                currentNode = currentNode->next;
            }
            return currentNode->value;
        }

    }

    int &operator[](size_t index)
    {
        Node *currentNode = this->head;
        for (unsigned int i = 0; i < index; ++i) {
            currentNode = currentNode->next;
        }
        return currentNode->value;

    }

    friend std::ostream &operator<<(std::ostream &os, const List &list)
    {
        List::Node *current = list.head;
        while (current != nullptr) {
            os << current->value << " ";
            current = current->next;
        }
        return os;
    }

    auto begin() const
    {
        return Iterator(head);
    }
    auto end() const
    {
        return Iterator(nullptr);
    }
    auto rbegin() const
    {
        // return ReverseIterator(end());
        return ReverseIterator(Iterator(secretNode));
    }
    auto rend() const
    {
        // return ReverseIterator(begin());
        return ReverseIterator(begin());
    }

    friend std::istream &operator>>(std::istream &is, List &list)
    {
        int value = 0;
        list.clear();
        while (is >> value) {
            list.pushBack(value);
        }
        return is;
    }

    bool contains(int n);

    unsigned int count(int n);

    struct Node
    {
    public:
        Node *next = nullptr;
        Node *prev = nullptr;
        int value = 0;

        Node() = default;
        ~Node() = default;

    };

    class Iterator {
    public:

        using value_type = int;
        using difference_type = std::ptrdiff_t;
        using pointer = int*;
        using reference = int&;
        using iterator_category = std::bidirectional_iterator_tag;

        Iterator()
        {
            currentNode = nullptr;
        }

        explicit Iterator(List::Node* newNode)
        {
            currentNode = newNode;
        }
        Iterator(const Iterator& other)
        {
            currentNode = other.currentNode;
        }

        Iterator& operator++() {
            if (currentNode != nullptr)
                currentNode = currentNode->next;
            return *this;
        }

        Iterator operator++(int) {
            Iterator placeholderNode = *this;
            ++(*this);
            return placeholderNode;
        }

        Iterator& operator--() {
            if (currentNode != nullptr)
                currentNode = currentNode->prev;
            return *this;
        }

        Iterator operator--(int) {
            Iterator placeholderNode = *this;
            --(*this);
            return placeholderNode;
        }
        // basically must return a reference to the node value that the iterator points to.
        int& operator*() const
        {
            return currentNode->value;
        }
        // must returns a pointer to the node value.
        int* operator->() const
        {
            return &(currentNode->value);
        }

        friend bool operator==(const Iterator& leftIterator, const Iterator& rightIterator)
        {
            return leftIterator.currentNode == rightIterator.currentNode;
        }

        friend bool operator!=(const Iterator& leftIterator, const Iterator& rightIterator)
        {
            return !(leftIterator == rightIterator);
        }

    private:
        unsigned int size = 0;
        List::Node* currentNode;
    };

private:
    List::Node* head = nullptr;
    List::Node* tail = nullptr;
    unsigned int size = 0;
    Node *secretNode = nullptr;
};

void List::clear() {
    Node* currentNode = head;
    while (currentNode != nullptr && currentNode != secretNode) {
        Node* nextNode = currentNode->next;
        delete currentNode;
        currentNode = nextNode;
    }
    head = nullptr;
    tail = nullptr;
    size = 0;

}


List::~List ()
{
    clear();
}

List::List ()
{
    head = nullptr;
    tail = nullptr;
    size = 0;
    secretNode = new Node();
    secretNode->prev = nullptr;
    secretNode->next = nullptr;
}

void List::pushFront(int data)
{
    Node* newNodeInFront = new Node();
    newNodeInFront->value = data;

    if (size == 0)
    {
        head = newNodeInFront;
        tail = newNodeInFront;
    }
    else
    {
        newNodeInFront->next = head;
        head->prev = newNodeInFront;
        head = newNodeInFront;
    }
    size++;
}

void List::pushBack(int data) {
    Node* newNodeInBack = new Node();
    newNodeInBack->value = data;

    if (size == 0) {
        head = newNodeInBack;
        tail = newNodeInBack;
    } else {
        newNodeInBack->prev = tail;
        tail->next = newNodeInBack;
        tail = newNodeInBack;
    }

    size++;
}

//Main constructors realization

// Just create a clear value list with some size but constructor :|
List::List(unsigned int n)
{
    head = nullptr;
    tail = nullptr;
    size = 0;
    while (n != 0) {
        this->pushBack(0);
        n--;
    }
}

//Something like Make From array but constructor :|
List::List(const int a[], size_t n)
{
    head = nullptr;
    tail = nullptr;
    size = 0;

    for(int i = 0; i < n; i++)
        this->pushBack(a[i]);
}

List::List(const List &copyList)
{
    head = nullptr;
    tail = nullptr;
    size = 0;

    Node* currentNode = copyList.head;
    while (currentNode != nullptr) {
        pushBack(currentNode->value);
        currentNode = currentNode->next;
    }
}

List::List(List&& other) noexcept
{
    head = other.head;
    tail = other.tail;
    size = other.size;
    other.head = nullptr;
    other.tail = nullptr;
    other.size = 0;
}
//Constructor finish
void List::popFront()
{
    Node* NodeToRemoveInFront = head;
    if (size == 0)
    {
        return;
    }
    else if (size == 1)
    {
        head = nullptr;
        tail = nullptr;
    }
    else
    {
        head = head->next;
        head->prev = nullptr;
    }
    delete NodeToRemoveInFront;
    size--;
}

void List::popBack()
{
    Node* NodeToRemoveInBack = tail;
    if (size == 0)
    {
        return;
    }
    else if ( size == 1)
    {
        head = nullptr;
        tail = nullptr;
    }
    else
    {
        tail = tail->prev;
        tail->next = nullptr;
    }
    delete NodeToRemoveInBack;
    size--;
}

int List::at(int index)
{
    if ( index >= 0 && index < size)
    {
        Node* currentNode = head;
        while(index > 0)
        {
            currentNode = currentNode->next;
            index--;
        }
        return currentNode->value;
    }
    else
        return 0;
}

unsigned int List::length() const
{
    return size;
}

bool List::empty() const
{
    return (size == 0);
}


bool List::isEqual(const List *compareWithList) const {
    if (size != compareWithList->size)
        return false;

    auto it1 = this->begin();
    auto it2 = compareWithList->begin();

    while (it1 != this->end() && it2 != compareWithList->end()) {
        if (*it1 != *it2)
            return false;
        ++it1;
        ++it2;
    }
    return true;
}
bool List::is_equal(const List &FirstList, const List &SecondList)
{
    if (FirstList.size != SecondList.size)
        return false;

    Node* currentNodeForFirstList = FirstList.head;
    Node* currentNodeForSecondList = SecondList.head;

    while (currentNodeForFirstList != nullptr && currentNodeForSecondList != nullptr) {
        if (currentNodeForFirstList->value != currentNodeForSecondList->value) {
            return false;
        }
        currentNodeForFirstList = currentNodeForFirstList->next;
        currentNodeForSecondList = currentNodeForSecondList->next;
    }
    return true;
}

void List::resize(unsigned int n)
{
    if (n > size) {
        while (size < n) {
            pushBack(0);
        }
    } else if (n < size) {
        while (size > n) {
            popBack();
        }
    }
}


void List::swap(List &a)
{
    Node *currentHead = head;
    head = a.head;
    a.head = currentHead;

    Node *currentTail = tail;
    tail = a.tail;
    a.tail = currentTail;

    unsigned int currentSize = size;
    size = a.size;
    a.size = currentSize;
}

void List::print()
{
    Node* newNode = head;
    for (int i=0; i<size; i++) {
        std::cout << newNode->value << " ";
        newNode = newNode->next;
    }
}
//operators overloading&newMethods:

List &List::operator=(const List &copyList)
{
    if(this == &copyList)
        return *this;

    else if (copyList.head == nullptr)
        return *this;

    else
    {
        clear();

        Node* currentCopyNode = copyList.head;
        Node* previousNewNode = nullptr;
        for (unsigned int i = 0; i < copyList.size; i++)
        {
            Node* newNode = new Node();
            newNode->value = currentCopyNode->value;

            if (i == 0) {
                this->head = newNode;
            } else if (previousNewNode != nullptr) {
                previousNewNode->next = newNode;
                newNode->prev = previousNewNode;
            }

            previousNewNode = newNode;
            currentCopyNode = currentCopyNode->next;
        }

        this->tail = previousNewNode;
        this->size = copyList.size;

        return *this;
    }
}

List &List::operator=(List &&moveList) noexcept
{
    if(this == &moveList)
        return *this;

    else if (moveList.head == nullptr)
        return *this;

    else
    {
        clear();
        this->head = moveList.head;
        this->tail = moveList.tail;
        this->size = moveList.size;

        moveList.head = nullptr;
        moveList.tail = nullptr;
        moveList.size = 0;
        return *this;
    }
}

bool operator==(const List &leftSideOfEqual, const List &rightSideOfEqual)
{
    leftSideOfEqual.head == rightSideOfEqual.head;
    return leftSideOfEqual.isEqual(&rightSideOfEqual);
}

bool operator!=(const List &leftSideOfEqual, const List &rightSideOfEqual)
{
    return !(leftSideOfEqual == rightSideOfEqual);
}

unsigned int List::count(int n)
{
    unsigned int count = 0;
    Node* newNode = head;
    while (newNode != nullptr)
    {
        if (newNode->value == n)
            count++;
        newNode = newNode->next;
    }
    return count;
}

bool List::contains(int n) {
    Node *newNode = head;
    for (unsigned i = 0; i < size; i++) {
        if (n == newNode->value)
            return true;
        else
            newNode = newNode->next;
    }
    return false;
}

bool operator<(const List &leftSideOfEqual, const List &rightSideOfEqual)
{
    List::Node *newNodeInLeft = leftSideOfEqual.head;
    List::Node *newNodeInRight = rightSideOfEqual.head;

    while (newNodeInLeft != nullptr && newNodeInRight != nullptr)
    {
        if (newNodeInLeft->value < newNodeInRight->value)
            return true;
        if (newNodeInLeft->value > newNodeInRight->value)
            return false;

        newNodeInLeft = newNodeInLeft->next;
        newNodeInRight = newNodeInRight->next;
    }

    if (newNodeInLeft == nullptr && newNodeInRight != nullptr)
        return true;
    if (newNodeInLeft != nullptr && newNodeInRight == nullptr)
        return false;

    return false;
}

List::List(Iterator begin, Iterator end) {
    head = nullptr;
    tail = nullptr;
    size = 0;
    for (Iterator it = begin; it != end; ++it) {
        pushBack(*it);
    }
    secretNode = new Node();
    secretNode->prev = tail;
}

int main(int argc, char const *argv[])
{
    int array[] = {19, 47, 74, 91};

    List a(array, 4);
    for (auto it = a.begin(); it != a.end(); ++it)
        std::cout << *it << " ";
    std::cout << std::endl;

    List b(a.begin(), a.end());
    assert(List::is_equal(a, b));
    for (auto it : b)
        std::cout << it << " ";
    std::cout << std::endl;

    List c(b.begin(), b.end());
    assert(std::equal(c.begin(), c.end(), b.begin()));
    for (auto it = c.rbegin(); it != c.rend(); ++it)
        std::cout << *it << " ";
    std::cout << std::endl;

    List d(c.rbegin(), c.rend());
    for (auto it : d)
        std::cout << it << " ";
    std::cout << std::endl;

    return 0;
}
